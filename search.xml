<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git学习总结]]></title>
    <url>%2F2019%2F07%2F05%2FGit%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git学习1.常用命git init 初始化，把目录变成Git可以管理的仓库 git add readme.txt 把文件添加到仓库 git commit -m “worte readme file” 提交，-m后面输入本次提交的说明 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt ​ 2 insertions`：插入了两行内容（readme.txt有两行内容） git status 查看仓库当前的状态，看是否有文件被修改 git diff readme.txt 看文件哪里被修改了 git log 命令显示从最近到最远的提交日志 git log –pretty=oneline 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 前面的是版本号，是通过SHA1计算出来的一个非常大的数字，因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 返回之前的版本12$ git reset --hard HEAD^HEAD is now at e475afc add distributed 在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 回归版本之后，最新的版本看不到了怎么办？ 别怕，在我们前面有 commit id，只要命令行窗口还没有关闭，就可以回到未来的版本 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 那要是命令行窗口关了，忘记id了肿么办？ 别怕，git reflog用来记录你的每一次命令 git reflog12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 工作区和暂存区工作区就是电脑里看得到的目录 暂存区存在于git的版本库中，add操作就是把文件添加到暂存区，commit之后就把所有内容都提交到当前分支master 撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： 123456$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 1$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 1234567$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 远程仓库第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 第3步：要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 创建和合并分支https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础学习笔记]]></title>
    <url>%2F2019%2F06%2F28%2Fpython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.关于列表当对列表进行截取操作时，返回的还是列表[1,2,3,4,5,6][1:6] 2.关于序列str,list,tuple(字符串，列表，元组)都是序列，都可以用切片来截取，都能用下标来选取相应的元素 3.关于集合set 元素是无序的，并且不能重复 {1,2,3,,4,5} 集合的相减 - 集合的交集 &amp; 集合的合并 | 4.值类型和引用类型int str tuple 不可变 list，dict可变 5.关于包里面的__init_.py文件对包进行初始化，每次调用包都会先执行其中的命令，像一次性import所需要的包 6.序列解包7.python中私有变量方法的表示在变量方法前面加双下划线”__” 8.python中的枚举12345678from enum import Enumclass Color(Enum): red = 1 blue = 2 green = 3 black = 4 white = 1 枚举类的定义与使用说明如下： （1）从enum中导入Enum类，以继承Enum类； （2）成员名称不允许重复，但值可以重复，相当于别名；值重复时，通过值只能取到第一个成员； （3）若要限制值不可重复，需增加装饰器@unique； （4）成员可进行同一性比较，但不可进行大小比较。 枚举的操作与字典类似，对于整个枚举结构，使用keys、values；但对于单个枚举值，对应name、value，而不是key、value。 遍历： 12for color in Color.__members__.items(): print(color[0]) 12345redbluegreenblackwhite 9.匿名函数，map以及reduce,filter函数12345678910111213from functools import reducel = [1,2,3,4,5,6]lb = map(lambda x:x*x,l)print(list(lb)) # [1, 4, 9, 16, 25, 36]# 连续计算 reducer = reduce(lambda x,y:x+y,l) # （（1+2）+3）+4...print(r) # 21# filter 过滤筛选list_x = [1,0,1,0,0,1,0]r = filter(lambda x:True if x==1 else False, list_x)print(list(r)) 10.装饰器装饰器就是为了在不破坏原来函数的基础上，对函数的功能进行添加，以闭包的方式，再用语法糖使得调用更加简单 1234567891011def decorate(f): def fd(): print("我是一个装饰器") f() return fd@decoratedef f1(): print("大家好")f1()# 我是一个装饰器# 大家好 当需要多个参数时，参数器怎么调用 12345678910111213141516171819202122232425262728import timedef timmer(func): """ :param func: 被装饰的函数 :return: 一个计算函数运行时间的函数 """ def wrapper(*args, **kwargs): """ :param args:收集被装饰函数的参数 :param kwargs:收集被装饰函数的关键字参数 :return: """ start_time = time.time() # 让进程睡一秒 time.sleep(1) # 调用被装饰的函数 result = func(*args, **kwargs) stop_time = time.time() print("&#123;func&#125; spend &#123;time&#125; ".format(func = "add", time = stop_time-start_time)) return result return wrapper@timmerdef add(x, y): print(x,y)add(1,2) 11.生成器对象12345678910111213141516171819202122232425import sysdef main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val)if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。 1234567891011121314def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield adef main(): for val in fib(20): print(val)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django课程学习]]></title>
    <url>%2F2019%2F06%2F27%2Fdjango-learn%2F</url>
    <content type="text"><![CDATA[1.Django的基本命令makemigrations 创建模型变更的迁移文件 migrate # 执行上一个命令创建的迁移文件 dumpdata #把数据库数据导出到文件 loaddate #把文件数据导入到数据库 2.重写authenticate已达到通过手机号，邮箱都能成功登陆在users.view文件中 123456789101112131415from django.contrib.auth.backends import ModelBackendfrom django.db.models import Qfrom .models import UserProfile# Create your views here.class CustomBackend(ModelBackend): def authenticate(self, username=None, password=None, **kwargs): try: user = UserProfile.objects.get(Q(username=username)|Q(email=username)) if user.check_password(password): return user except Exception as e: return None 在setting文件中 1234# Application definitionAUTHENTICATION_BACKENDS = ( 'users.views.CustomBackend',) 另外在登陆的HTML文件中也可以通过if进行判断 1&#123;% if request.user.is_authenticated %&#125; 3.通过继承django自带的类来管理get和post请求所需要用的包 1from django.views.generic.base import View 示例 123456789101112class LoginView(View): def get(self, request): return render(request, "login.html") def post(self, request): user_name = request.POST.get("username", "") pass_word = request.POST.get("password", "") user = authenticate(username=user_name, password=pass_word) if user is not None: login(request, user) return render(request, "index.html") else: return render(request, "login.html", &#123;"msg": "用户名或者密码错误"&#125;) 在url路径中修改 1url(r'^login/$', LoginView.as_view(), name="login") 4.使用forms对表单数据进行校验本质上就是个filter，需要注意的是username和password要和表单上的name一样 12345# -*- coding:UTF-8 -*-from django import formsclass LoginForm(forms.Form): username = forms.CharField(required=True) password = forms.CharField(required=True, min_length=5) 12345def post(self, request): # 创建一个forms验证器 Login_form = LoginForm(request.POST) if Login_form.is_valid(): .... 5.cookie和session机制在django中的体现①cookie的含义：http请求本身是无状态请求，不能保存用户的状态信息，后来就产生了cookie，用户向服务器（也就是网站）发起请求时，服务器会返回一个id，这个id就是个随机文本，记录了用户的请求信息，然后这个id便存储在本地浏览器，注意是本地，本地，本地，下次用户访问服务器时，服务器认识了这个id，就不用重新分配id，也就是不用重新登陆了，但是，因为存储在本地，用户信息容易被窃取，使用（比如某一天，别人用你的电脑上某些网站）②session的含义：因此session就出现了，session是存在服务器上的，用户访问服务器时，服务器会生成一段随机字符，以键值对的形式存储在数据库中，并且有定时销毁机制（总不能让你登陆一次就存在服务器数据库一年吧），服务器把session id返回给用户，存储在浏览器中，用户在访问时，可以成功登陆，但登陆账号密码那些已经作为加密字段存储在服务器数据库里了，因此session是cookie的升级，比cookie安全很多。 登陆成功后，自动添加到session表中 django的具体登陆校验的过程见下 https://www.cnblogs.com/ccorz/p/6357815.html 6.使用navicat生成数据字典https://blog.csdn.net/cxh6863/article/details/84499255 7.django中filter和get的区别https://blog.csdn.net/qq_29113041/article/details/78079165 8.template替换后台数据 在url中对图片访问地址进行配置，首先import进django.views.static import 1url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;"document_root": MEDIA_ROOT&#125;) 9.通过第三方库实现分页功能https://github.com/jamespacileo/django-pure-pagination 10.AJAX技术https://blog.csdn.net/hz_940611/article/details/80850075 11.django自带的过滤器功能这是django自带的模板机制，可以不通过改变python代码实现对数据的预处理，比如截取部分长度的字符串做判断等 https://www.jianshu.com/p/b385f774d49e 12.django的ORM搜索功能以及P模块https://www.zmrenwu.com/post/19/]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2019%2F06%2F24%2FjQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[jQuery基本概念学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。 为什么要学习jQuery？【01-让div显示与设置内容.html】 使用javascript开发过程中，有许多的缺点： 123451. 查找元素的方法太少，麻烦。2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。3. 有兼容性问题。4. 想要实现简单的动画效果，也很麻烦5. 代码冗余。 jQuery初体验【02-让div显示与设置内容.html】 1234567891011$(document).ready(function () &#123; $("#btn1").click(function () &#123; //隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 $("div").show(200); &#125;); $("#btn2").click(function () &#123; $("div").text("我是内容"); &#125;);&#125;);12345678910 优点总结： 1234561. 查找元素的方法多种多样，非常灵活2. 拥有隐式迭代特性，因此不再需要手写for循环了。3. 完全没有兼容性问题。4. 实现动画非常简单，而且功能更加的强大。5. 代码简单、粗暴。12345 没有对比，就没有伤害，有了对比，处处戳中要害。 什么是jQuery? jQuery的官网 http://jquery.com/jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。 js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js） 我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。 jQuery的版本 官网下载地址：http://jquery.com/download/jQuery版本有很多，分为1.x 2.x 3.x 大版本分类： 1234561.x版本：能够兼容IE678浏览器2.x版本：不兼容IE678浏览器1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。3.x版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）12345 关于压缩版和未压缩版 123jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。12 jQuery的入口函数使用jQuery的三个步骤： 12341. 引入jQuery文件2. 入口函数3. 功能实现123 关于jQuery的入口函数： 123456789//第一种写法$(document).ready(function() &#123; &#125;);//第二种写法$(function() &#123; &#125;);12345678 jQuery入口函数与js入口函数的对比 1231. JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。2. jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。12 jQuery对象与DOM对象的区别（重点）123451. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））4. DOM对象与jQuery对象的方法不能混用。1234 DOM对象转换成jQuery对象：【联想记忆：花钱】 1234var $obj = $(domObj);// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象123 jQuery对象转换成DOM对象： 1234567var $li = $(“li”);//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0)123456 【练习：隔行变色案例.html】 选择器什么是jQuery选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 过滤选择器 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 【案例：隔行变色】 筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 12345【案例：下拉菜单】this+children+mouseenter+mouseleave【案例：突出展示】siblings+find【案例：手风琴】next+parent【案例：淘宝精品】index+eq1234 jQuery操作样式 css操作 获取样式 $(ele).css(attr); //注意，只会获取第一个元素的样式值 设置单个样式$(ele).css(attr,value); 设置多个样式$(ele).css(obj); class操作 添加类：$(ele).addClass(className); 移除类：$(ele).removeClass(className); 判断类：$(ele).hasClass(className); 切换类：$(ele).toggleClass(className) //隐式迭代 设置操作的时候：会给jq内部的所有对象都设置上相同的值。 //获取的时候，只会返回第一个元素对应的值 jQuery操作属性获取属性：$(ele).attr(name); 设置单个属性 $(ele).attr(name,value); 设置多个属性$(ele).attr(obj); 注意 对于布尔类型的属性（例如checked,disable,selected），不要attr方法，应该用prop方法 插件常用插件 插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。 jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。 jquery.color.js animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。 使用插件的步骤 123451. 引入jQuery文件2. 引入插件（如果有用到css的话，需要引入css）3. 使用插件1234 jquery.lazyload.js懒加载插件 jquery.ui.js插件jQueryUI专指由jQuery官方维护的UI方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用: 123452. 1. 引入jQueryUI的样式文件2. 引入jQuery3. 引入jQueryUI的js文件4. 使用jQueryUI功能1234 使用jquery.ui.js实现新闻模块的案例 制作jquery插件 原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。 123//通过给$.fn添加方法就能够扩展jquery对象$.fn. pluginName = function() &#123;&#125;;12 制作手风琴插件]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 如何在文章摘要中插入图片]]></title>
    <url>%2F2019%2F04%2F27%2FHexo-Next-%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[哇，漂亮的小姐姐(❤ ω ❤)]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>“hexo”</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F25%2FREADME%2F</url>
    <content type="text"><![CDATA[hexo-theme-yiliaYilia 是为 hexo 2.4+制作的主题。崇尚简约优雅，以及极致的性能。 你可以点击 我的博客 查看效果。 如果想体验手机浏览效果，可以扫一下二维码： ————————————————————— 关于主题： 崇尚简约 追求移动端体验 希望把加载速度做到极致（努力中） 让大家把注意力放到内容上。这是本主题设计初衷 主题不支持IE6，7，8。以后也不会 近期更新（2017.07.09）： 2017.07.09 返回顶部 TOC目录 2016.12.04 打赏 搜索 “更好的”标签云 “更好的”分享 一些动画 计划中： 移动端优化 一、外观####常规 ####手机 ####ipad横竖屏切换 二、开发者为了性能和开发工程化考虑，Yilia需要使用webpack进行构建生成。 如果您对主题有一些定制化的需求，请参考wiki《Yilia源码目录结构及构建须知》 三、使用安装1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置修改hexo根目录下的 _config.yml ： theme: yilia 更新12cd themes/yiliagit pull 四、配置主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。完整配置例子，可以参考我的博客备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# Headermenu: 主页: / 随笔: /tags/随笔/# SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos;# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: &apos;&apos; #存储评论的 repogitment_oauth: client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#4d4d4d&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos;friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家]]></content>
  </entry>
</search>
